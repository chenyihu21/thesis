% !TeX root = ../cyh.tex

\chapter{引言}

\section{课题背景}

\subsection{操作系统宏内核}

操作系统是计算机硬件和用户之间的接口。它负责管理和调度计算机的硬件资源（如CPU、内存、输入输出设备等），同时为用户提供一个易于使用的操作界面，使得用户可以通过简单的命令或图形界面来操作计算机。操作系统内核是计算机系统的核心组件，它负责管理计算机硬件资源（如处理器、内存、输入输出设备等）和提供用户程序运行的环境。随着计算机技术的不断发展，操作系统内核也在不断演化和改进，以适应不同的使用场景和需求。而根据操作系统内核的设计模式，又可以将操作系统内核划分为不同的类型，如微内核、宏内核等。

宏内核是一种操作系统内核的设计模式，它将操作系统的所有功能（如进程管理、内存管理、文件系统、设备驱动等）集成在一个单一的地址空间中。整个内核运行在内核态，具有较高的执行效率。宏内核的优点是可以提供更好的性能和更灵活的功能，但是也存在一些缺点，如内核的复杂性和可拓展行问题——当需要添加或修改功能时，可能会涉及到多个模块的修改；内核的稳定性问题——当出现故障时，可能会导致整个系统崩溃。

\subsection{操作系统的组件化}

为了增强操作系统的可拓展性和稳定性，操作系统通常采用组件化设计。组件化设计是一种将操作系统的功能划分为多个模块的设计模式，每个组件负责特定的功能，组件之间通过明确定义的接口进行通信。这样做的好处是可以提高系统的可拓展性和稳定性，因为每个组件都可以独立开发、测试和维护。

\subsection{操作系统的内存管理}

内存管理是操作系统的核心功能之一，它负责管理和分配计算机系统的内存资源。内存管理的主要目标是确保系统能够高效地利用有限的物理内存，同时为用户提供透明的、虚拟的内存空间。内存管理模块的主要功能包括：

\begin{itemize}
\item 内存分配：当用户程序请求内存时，内存管理模块需要从可用的内存池中分配一块合适的内存空间给程序。分配策略可以是多种多样的，如首次适应、最佳适应、最坏适应等。
\item 内存回收：当用户程序释放内存时，内存管理模块需要将这块内存回收到可用内存池中。回收时需要考虑内存碎片问题，如合并相邻的空闲内存块等。
\item 内存保护：内存管理模块需要确保每个进程只能访问自己被分配的内存区域，防止一个进程非法访问其他进程的内存空间。还可以设置不同的访问权限，例如只读、可读写等。
\item 虚拟内存管理：虚拟内存是一种计算机系统内存管理技术，它使得应用程序认为自身拥有一块连续的、足够大的内存空间，实际上这些内存可能被分隔成多个物理内存碎片，并且部分数据可能暂时存储在外部磁盘上。当程序运行时，需要的数据会从磁盘交换到物理内存中。虚拟内存通常以页面为单位进行管理。内存管理模块负责将虚拟内存地址映射到物理内存地址，并且当物理内存不足，需要从磁盘上读取页面时，内存管理模块需要决定将哪个页面从物理内存中置换到磁盘上。常见的页面置换算法包括先进先出（FIFO）、最近最少使用（LRU）等。
\item 内存映射：内存映射是一种将磁盘上的文件映射到内存中的技术，使得应用程序可以像访问内存一样访问文件，这种方式可以提高文件访问的效率，因为它减少了文件I/O操作的开销。内存管理模块负责将磁盘上的文件映射到内存中，并提供相应的接口供应用程序访问。
\item 共享内存：共享内存是一种允许多个进程共享同一块内存区域的技术，这种技术可以提高进程间的通信效率，因为它避免了数据的复制。内存管理模块负责管理共享内存区域，并提供相应的接口供应用程序访问。
\end{itemize}

\section{相关研究工作}

除了 Linux 内核，还有许多其他较为完善的操作系统内核，如 DragonOS、星绽、ByteOS 等。这些操作系统内核都提供了自己的内存管理模块，并且在内存管理的设计和实现上有所不同。

\subsection{DragonOS}

DragonOS 是一个面向云计算轻量化场景的，完全自主内核的，提供 Linux 二进制兼容性的 64 位操作系统，它具有优秀完善的架构设计，支持虚拟化，在设备模型、调度子系统等方面具有一定优势。DragonOS的内存管理模块主要由以下类型的组件组成：

\begin{itemize}
\item 硬件抽象层（MemoryManagementArch） - 提供对具体处理器架构的抽象，使得内存管理模块可以在不同的处理器架构上运行

\item 页面映射器（PageMapper）- 提供对虚拟地址和物理地址的映射，以及页表的创建、填写、销毁、权限管理等操作。分为两种类型：内核页表映射器（KernelMapper）和用户页表映射器（位于具体的用户地址空间结构中）

\item 页面刷新器（PageFlusher） - 提供对页表的刷新操作（整表刷新、单页刷新、跨核心刷新）

\item 页帧分配器（FrameAllocator） - 提供对页帧的分配、释放、管理等操作。具体来说，包括BumpAllocator、BuddyAllocator

\item 小对象分配器 - 提供对小内存对象的分配、释放、管理等操作。指的是内核里面的SlabAllocator （SlabAllocator的实现目前还没有完成）

\item MMIO空间管理器 - 提供对MMIO地址空间的分配、管理操作。（目前这个模块待进一步重构）

\item 用户地址空间管理机制 - 提供对用户地址空间的管理。

\item VMA机制 - 提供对用户地址空间的管理，包括VMA的创建、销毁、权限管理等操作

\item 用户映射管理 - 与VMA机制共同作用，管理用户地址空间的映射

\item 系统调用层 - 提供对用户空间的内存管理系统调用，包括mmap、munmap、mprotect、mremap等

\item C接口兼容层 - 提供对原有的C代码的接口，使得C代码能够正常运行。
\end{itemize}

DragonOS 使用 AddressSpace 结构体来管理用户地址空间，这个结构体包含了诸多成员，
如 mappings（VMA 列表）、mmap\_min（最小映射地址）、brk（堆的当前顶部地址）等，这些成员用于管理用户地址空间的不同区域。其中 UserMappings(mappings) 代表了用户虚拟内存空间，并且提供了查找、插入、删除用户虚拟内存区域 VMA 的接口，VMA 中包含了虚拟内存区域的起始地址、结束地址、权限等信息，一个 VMA 可能包含多个虚拟页，每个虚拟页都对应一个物理页帧。虚拟地址和物理地址的映射由页表管理器 PageMapper 来管理，PageMapper 包含页表类型等属性，指定了物理页帧分配器的类型，提供管理页表、虚拟地址与物理地址相互映射的接口，并连接到物理内存管理器，提供物理页帧的分配和回收等功能。

DragonOS 的物理内存由物理页管理器 (PageManager) 管理，它是一个以物理地址和物理页对象为键值对的哈希表，使用页帧分配器进行物理页的分配，使用页面回收线程和页面回收器来回收空闲的物理页。

当用户程序需要对内存进行操作，例如分配内存时，它会调用相应的 mmap 系统调用，系统调用 AddressSpace 结构体的接口在用户地址空间中创建一个新的虚拟内存区域，并通过页表管理器分配物理页，将其映射到物理内存中；当用户程序需要释放内存时，它会调用 munmap 系统调用，munmap 系统调用会将用户地址空间中的虚拟内存区域与物理内存中的物理页断开映射关系，释放物理页，并将虚拟内存区域从用户地址空间中删除，在需要写回的情况下，会唤醒页面回收线程，将物理页标记为可回收状态，由页面回收器进行回收。

\subsection{星绽}

星绽 (asterinas) 是一个用 Rust 编写的安全、快速且通用的操作系统内核，且与 Linux 兼容。在物理内存管理方面，星绽定义了多种内存区域类型，如 BadMemory、Unknown、NonVolatileSleep、Reserved、Kernel、Module、Framebuffer、Reclaimable 和 Usable，以帮助内核识别不同用途的内存区域。使用 MemoryRegion 结构体表示一个内存区域，包含基地址、长度和类型信息；使用 MemoryRegionArray 无堆集合管理多个内存区域，它提供了 push 方法用于添加区域，into\_non\_overlapping 方法用于将区域排序并合并为非重叠的区域集合。

在虚拟内存管理方面，星绽用 Vmo 结构体来表示虚拟内存实例，提供了读写内存页的接口。进程的虚拟内存空间则由 ProcessVm 结构体表示，它包含一个根 Vmar（虚拟内存地址区域），而 Vmar 则关联着用户模式任务的虚拟内存空间管理器 VmSpace 和内存映射实例 VmMapping 的集合。VmSpace 结包含页表等信息，并提供了内存映射的相关接口。当为进程分配虚拟内存时，ProcessVm 会借助 Vmar 来创建和管理内存映射，而这些映射最终会反映在关联的 VmSpace 中。

在更上层的系统调用接口方面，星绽提供了与 Linux 兼容的系统调用接口，如 mmap、munmap、mprotect、mremap 等，这些接口可以被用户程序调用，用于管理用户模式任务的虚拟内存空间。

\subsection{ByteOS}

ByteOS 是一个基于 Rust 语言开发的组件化操作系统宏内核，由进程管理、内存管理、文件系统、网络协议栈等多个模块组成。ByteOS 的内存管理模块主要包括以下几个部分：

\begin{itemize}
\item 堆内存空间定义：定义了一个静态的堆内存数组 HEAP，其大小由 HEAP\_SIZE 常量指定。
\item 全局堆内存分配器：使用 buddy\_system\_allocator::LockedHeap 实现了一个全局的堆内存分配器 HEAP\_ALLOCATOR。
\item 物理页帧管理：FrameTracker 用于表示一个已经被分配的页帧，并且利用 Drop 机制保证页帧能够顺利被回收。当 FrameTracker 实例被销毁时，会自动调用 drop 方法，将对应的页帧标记为未使用状态。FrameRegionMap 是页帧分布图，用于保存页帧分配器中的空闲内存，并且利用 BitArray 记录页帧使用情况。每个 FrameRegionMap 表示一段连续的物理内存区域。FrameAllocator 是一个总的页帧分配器，包含多个 FrameRegionMap，负责管理整个系统的物理页帧分配与释放。
\item 内存映射：使用 MapTrack 结构体表示一个内存映射，包含虚拟地址和对应的物理页帧 FrameTracker。
\item 页帧分配函数：在 UserTask 结构体包含进程页表、进程控制块、虚拟内存空间等信息，并提供了 frame\_alloc 和 map\_frames 方法用于页帧分配和映射。
\item 进程内存空间管理：MemArea 结构体表示一个内存区域，包含内存类型、页帧映射、文件关联等信息，多个 MemArea 组成一个 MemSet。进程控制块中记录了进程使用的内存区域，并通过页表机制实现虚拟内存到物理内存的映射。
\item 系统调用接口：提供了 mmap、munmap、mprotect、mremap 等系统调用接口，用于进程内存管理。
\end{itemize}

当用户程序当用户进程申请一块内存时，ByteOS 会根据不同的系统调用（如 sys\_mmap 或 sbrk），进而调用用户进程（UserTask）的 frame\_alloc 接口，通过物理页帧分配器申请物理页帧，创建新的虚拟内存区域，并将其映射到物理内存中，最后将虚拟内存区域加入到进程的内存空间中进行管理。

\section{课题内容和意义}

\subsection{课题内容}

本课题的内容是基于 ArceOs 基座和 starry-next 宏内核的已有结构，实现内存管理模块及其接口的设计与实现，包括实现对 ArceOs 和 starry-next 的内存管理模块的设计与分析，以及内存管理直接或间接相关的系统调用的实现，并对内存管理模块及其接口进行测试。

\subsection{课题意义}

通过研究并设计实现宏内核内存管理组件与系统调用接口，可以明确内存管理系统的职责和边界，帮助内存管理系统作为一个独立的模块进行设计和实现。实现系统调用也有助于发现和解决当前内存管理组件可能存在的问题。

不同的应用场景对内存管理有着不同的要求。模块化的内存管理系统能有效降低功能拓展的难度，可以根据需求进行相对独立的配置和开发。而统一的系统调用接口的实现也有助于内存管理组件根据具体的应用场景，提供相应的内存管理策略和优化措施，满足多样化的应用需求。

\section{论文结构}

本文分为 6 个章节。其中，第一章节主要介绍课题背景、相关研究和与课题内容，第二章节将介绍基座 ArceOS 的组件与其内存管理，第三章节将介绍 starry-next 宏内核的架构和内存管理模块的设计，第四章节将介绍 starry-next 内存管理模块接口的设计和实现，第五章节将介绍接口的测试。第六章节是对工作的总结与展望。